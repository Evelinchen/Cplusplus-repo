/*========================Program Description=======================
程序名称：c++语言中指针经典问题
程序目的：通过例题增加对指针的深度理解（涉及行指针&列指针）
Written By Dong-Hong Yan(2012-4-3)
===================================================================*/

#include <iostream>
using namespace std;

int main(void)
{
    int p[10][10] = 
    {    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 
        10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 
        20, 21, 22, 23, 24, 25, 26, 27, 28, 29,
        30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 
        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 
        50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 
        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 
        70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 
        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 
        90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 
    };
    int (*ptr)[10];            //在这里，定义ptr是一个是一个指向一维10个元素的指针，是行指针！能在行之间移动 
    ptr=p;

    // 下面四条语句均输出56
    cout << p[5][6] << endl;
    cout << *((int*)p[5] + 6) << endl;    // (int*)&p[5]就是第5行的首地址，整句话就是第5行的第6个元素,这里的&可以去掉，只是让看程序的方便理解是地址 
    cout << *((int*)&p + 5 * 10 + 6) << endl;    // (int*)p就是p[0][0]的地址，整句话就是p[0][0]开始后的第56个元素
    cout<<*(*(ptr+5)+6)<<endl;                  //在这里，一开始，ptr是行指针，（ptr+5）是指向第五行，行的地址，而*(ptr+5)是将行指针转化列指针，而 
                                              //*(ptr+5)+6是第5行第6个元素的地址，然后再加*号，表示元素的值 
    system("pause");                            

    return 0;
}
/*【心得】：1。 指针的类型。 从语法的角度看，你只要把指针声明语句里的指针名字去掉，剩下的部分就 是这个指针的类型。这是指针本身所具有的类型。
让我们看看例一中各个指针的 类型： 
     (1)int *ptr; //指针的类型是int * 
     (2)char *ptr; //指针的类型是char * 
     (3)int **ptr; //指针的类型是 int ** 
     (4)int (*ptr)[3]; //指针的类型是 int(*)[3] 
     (5)int *(*ptr)[4]; //指针的类型是 int *(*)[4] 
     怎么样？找出指针的类型的方法是不是很简单？ 

           2。指针所指向的类型。 
当你通过指针来访问指针所指向的内存区时，指针所指向的类型决定了编译 器将把那片内存区里的内容当做什么来看待。 从语法上看，你只须把指针声明语句
中的指针名字和名字左边的指针声明符 *去掉，剩下的就是指针所指向的类型。例如： 
      (1)int *ptr; //指针所指向的类型是int 
     (2)char *ptr; //指针所指向的的类型是char 
     (3)int **ptr; //指针所指向的的类型是 int *          指向指针的指针 
     【 Int a = 100; int *p1 = &a;int **p = &p1;printf("%d",**p);结果是100】 
     (4)int (*ptr)[3]; //指针所指向的的类型是 int()[3]          指向一维数组的指针 
     (5)int *(*ptr)[4]; //指针所指向的的类型是 int *()[4]           指向指针数组的指针 
在指针的算术运算中，指针所指向的类型有很大的作用。 指针的类型(即指针本身的类型)和指针所指向的类型是两个概念。当你对C越 
来越熟悉时，你会发现，把与指针搅和在一起的“类型”这个概念分成“指针的 类型”和“指针所指向的类型”两个概念，是精通指针的关键点之一。我看了不 
少书，发现有些写得差的书中，就把指针的这两个概念搅在一起了，所以看起书 来前后矛盾，越看越糊涂。 



3。 指针的值，或者叫指针所指向的内存区或地址。 指针的值是指针本身存储的数值，这个值将被编译器当作一个地址，而不是 一个一般的数值。在32位程序
里，所有类型的指针的值都是一个32位整数，因为 32位程序里内存地址全都是32位长。 指针所指向的内存区就是从指针的值所代表的那个内存地址开始，长度
为sizeof(指针所指向的类型)的一片内存区。以后，我们说一个指针的值是XX，就相 当于说该指针指向了以XX为首地址的一片内存区域；我们说一个指针指向了
某块 内存区域，就相当于说该指针的值是这块内存区域的首地址。 指针所指向的内存区和指针所指向的类型是两个完全不同的概念。在例一中 ，指针所指向的
类型已经有了，但由于指针还未初始化，所以它所指向的内存区 是不存在的，或者说是无意义的。 以后，每遇到一个指针，都应该问问：这个指针的类型是什么？指针指向的 
类型是什么？该指针指向了哪里？
 
4。 指针本身所占据的内存区。 
指针本身占了多大的内存？你只要用函数sizeof(指针的类型)测一下就知道 了。在32位平台里，指针本身占据了4个字节的长度。 
指针本身占据的内存这个概念在判断一个指针表达式是否是左值时很有
*/ 

